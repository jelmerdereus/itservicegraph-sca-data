{"critical":[{"cwe_ids":["78"],"id":"go_gosec_injection_subproc_injection","title":"Unsanitized dynamic input in OS command","description":"## Description\n\nUsing unsanitized dynamic or external input in an OS command is a critical security flaw that can enable attackers to execute unauthorized commands on the host operating system, potentially leading to a complete system takeover.\n\n## Remediations\n\n- **Do not** construct OS commands or command-line arguments using externally-supplied information. This practice can introduce command injection vulnerabilities.\n  ```go\n  cmd := exec.Command(\"bash\", \"-c\", \"echo \" + externalInput) // unsafe\n  ```\n- **Do** validate all external input against a strict set of rules to ensure it does not include harmful characters or patterns.\n  ```go\n  if !regexp.MustCompile(`^[a-zA-Z0-9]+$`).MatchString(externalInput) {\n    log.Fatal(\"Invalid input\")\n  }\n  ```\n- **Do** use hardcoded arguments when invoking OS commands to prevent external input from altering the command's execution.\n  ```go\n  cmd := exec.Command(\"ls\", \"-l\", \"/var/log\")\n  ```\n- **Do** prefer native libraries or programming language features over invoking shell commands for enhanced security and efficiency.\n\n## References\n\n- [OWASP OS Command Injection Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_injection_subproc_injection","line_number":76,"full_filename":"cmd/commandfuncs.go","filename":"cmd/commandfuncs.go","category_groups":["PII","Personal Data"],"source":{"start":76,"end":76,"column":{"start":9,"end":74}},"sink":{"start":76,"end":76,"column":{"start":9,"end":74},"content":""},"parent_line_number":76,"fingerprint":"eb63b637da6ea909858412e22faf79ce_0","old_fingerprint":"eb63b637da6ea909858412e22faf79ce_0","code_extract":"\tcmd := exec.Command(os.Args[0], \"run\", \"--pingback\", ln.Addr().String())"},{"cwe_ids":["78"],"id":"go_gosec_injection_subproc_injection","title":"Unsanitized dynamic input in OS command","description":"## Description\n\nUsing unsanitized dynamic or external input in an OS command is a critical security flaw that can enable attackers to execute unauthorized commands on the host operating system, potentially leading to a complete system takeover.\n\n## Remediations\n\n- **Do not** construct OS commands or command-line arguments using externally-supplied information. This practice can introduce command injection vulnerabilities.\n  ```go\n  cmd := exec.Command(\"bash\", \"-c\", \"echo \" + externalInput) // unsafe\n  ```\n- **Do** validate all external input against a strict set of rules to ensure it does not include harmful characters or patterns.\n  ```go\n  if !regexp.MustCompile(`^[a-zA-Z0-9]+$`).MatchString(externalInput) {\n    log.Fatal(\"Invalid input\")\n  }\n  ```\n- **Do** use hardcoded arguments when invoking OS commands to prevent external input from altering the command's execution.\n  ```go\n  cmd := exec.Command(\"ls\", \"-l\", \"/var/log\")\n  ```\n- **Do** prefer native libraries or programming language features over invoking shell commands for enhanced security and efficiency.\n\n## References\n\n- [OWASP OS Command Injection Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_injection_subproc_injection","line_number":239,"full_filename":"cmd/packagesfuncs.go","filename":"cmd/packagesfuncs.go","category_groups":["PII","Personal Data"],"source":{"start":239,"end":239,"column":{"start":9,"end":76}},"sink":{"start":239,"end":239,"column":{"start":9,"end":76},"content":""},"parent_line_number":239,"fingerprint":"eb8030450c4e995786e00534159d6639_0","old_fingerprint":"eb8030450c4e995786e00534159d6639_1","code_extract":"\tcmd := exec.Command(path, \"list-modules\", \"--versions\", \"--skip-standard\")"},{"cwe_ids":["78"],"id":"go_gosec_injection_subproc_injection","title":"Unsanitized dynamic input in OS command","description":"## Description\n\nUsing unsanitized dynamic or external input in an OS command is a critical security flaw that can enable attackers to execute unauthorized commands on the host operating system, potentially leading to a complete system takeover.\n\n## Remediations\n\n- **Do not** construct OS commands or command-line arguments using externally-supplied information. This practice can introduce command injection vulnerabilities.\n  ```go\n  cmd := exec.Command(\"bash\", \"-c\", \"echo \" + externalInput) // unsafe\n  ```\n- **Do** validate all external input against a strict set of rules to ensure it does not include harmful characters or patterns.\n  ```go\n  if !regexp.MustCompile(`^[a-zA-Z0-9]+$`).MatchString(externalInput) {\n    log.Fatal(\"Invalid input\")\n  }\n  ```\n- **Do** use hardcoded arguments when invoking OS commands to prevent external input from altering the command's execution.\n  ```go\n  cmd := exec.Command(\"ls\", \"-l\", \"/var/log\")\n  ```\n- **Do** prefer native libraries or programming language features over invoking shell commands for enhanced security and efficiency.\n\n## References\n\n- [OWASP OS Command Injection Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/OS_Command_Injection_Defense_Cheat_Sheet.html)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_injection_subproc_injection","line_number":246,"full_filename":"cmd/packagesfuncs.go","filename":"cmd/packagesfuncs.go","category_groups":["PII","Personal Data"],"source":{"start":246,"end":246,"column":{"start":9,"end":38}},"sink":{"start":246,"end":246,"column":{"start":9,"end":38},"content":""},"parent_line_number":246,"fingerprint":"eb8030450c4e995786e00534159d6639_1","old_fingerprint":"eb8030450c4e995786e00534159d6639_2","code_extract":"\tcmd := exec.Command(path, \"version\")"},{"cwe_ids":["94"],"id":"go_gosec_subproc_subproc","title":"Unsanitized external input in code execution","description":"## Description\n\nUnsanitized external input in code execution can result in code injection. This vulnerability arises when external or user-provided data is directly used in the execution flow of a program without proper sanitization, potentially leading to unauthorized actions or access.\n\n## Remediations\n\n- **Do not** pass unsanitized external input directly to execution functions. This practice can introduce code injection vulnerabilities.\n- **Do** implement thorough input validation. Ensure all external input is checked against a strict set of rules to verify it does not contain harmful characters or patterns.\n\n## References\n\n- [OWASP Code injection explained](https://owasp.org/www-community/attacks/Code_Injection)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_subproc_subproc","line_number":133,"full_filename":"context.go","filename":"context.go","category_groups":["PII","Personal Data"],"source":{"start":133,"end":133,"column":{"start":9,"end":69}},"sink":{"start":133,"end":133,"column":{"start":9,"end":69},"content":""},"parent_line_number":133,"fingerprint":"cab7ee6d0148ae190f5e7055c27d17cf_0","old_fingerprint":"cab7ee6d0148ae190f5e7055c27d17cf_0","code_extract":"\tval := reflect.ValueOf(structPointer).Elem().FieldByName(fieldName)"}],"high":[{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_random","title":"Usage of weak Pseudo-Random Number Generator (PRNG)","description":"## Description\n\nThe `math/rand` package in Go generates pseudorandom numbers that are not secure for cryptographic purposes. These numbers can be predicted if the seed is known, posing a risk to the security of applications that use them for generating secrets, tokens, or other security-sensitive elements.\n\n## Remediations\n\n- **Do** use `crypto/rand` instead of `math/rand` for generating random numbers in contexts where security is crucial. This ensures the randomness is cryptographically secure and unpredictable.\n- **Do not** use `math/rand` for generating random numbers in cryptographic applications, including but not limited to key generation, authentication tokens, or security challenges.\n- **Do not** initialize `math/rand` with predictable seeds, such as timestamps or other easily guessable values, if it is required to use `math/rand`.\n\n## References\n\n- [crypto/rand package documentation](https://pkg.go.dev/crypto/rand)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_random","line_number":258,"full_filename":"modules/caddyhttp/caddyauth/basicauth.go","filename":"modules/caddyhttp/caddyauth/basicauth.go","category_groups":["PII","Personal Data"],"source":{"start":258,"end":258,"column":{"start":10,"end":37}},"sink":{"start":258,"end":258,"column":{"start":10,"end":37},"content":""},"parent_line_number":258,"fingerprint":"6944abe0a3e390ca4a5ca9592444a7bc_0","old_fingerprint":"6944abe0a3e390ca4a5ca9592444a7bc_5","code_extract":"\t\trnd := weakrand.Intn(len(c.cache))"},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_random","title":"Usage of weak Pseudo-Random Number Generator (PRNG)","description":"## Description\n\nThe `math/rand` package in Go generates pseudorandom numbers that are not secure for cryptographic purposes. These numbers can be predicted if the seed is known, posing a risk to the security of applications that use them for generating secrets, tokens, or other security-sensitive elements.\n\n## Remediations\n\n- **Do** use `crypto/rand` instead of `math/rand` for generating random numbers in contexts where security is crucial. This ensures the randomness is cryptographically secure and unpredictable.\n- **Do not** use `math/rand` for generating random numbers in cryptographic applications, including but not limited to key generation, authentication tokens, or security challenges.\n- **Do not** initialize `math/rand` with predictable seeds, such as timestamps or other easily guessable values, if it is required to use `math/rand`.\n\n## References\n\n- [crypto/rand package documentation](https://pkg.go.dev/crypto/rand)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_random","line_number":101,"full_filename":"modules/caddyhttp/errors.go","filename":"modules/caddyhttp/errors.go","category_groups":["PII","Personal Data"],"source":{"start":101,"end":101,"column":{"start":15,"end":31}},"sink":{"start":101,"end":101,"column":{"start":15,"end":31},"content":""},"parent_line_number":101,"fingerprint":"c4795a0511879ac4ac487d3ac25e1510_0","old_fingerprint":"c4795a0511879ac4ac487d3ac25e1510_2","code_extract":"\t\tb[i] = dict[weakrand.Int63()%int64(len(dict))]"},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_random","title":"Usage of weak Pseudo-Random Number Generator (PRNG)","description":"## Description\n\nThe `math/rand` package in Go generates pseudorandom numbers that are not secure for cryptographic purposes. These numbers can be predicted if the seed is known, posing a risk to the security of applications that use them for generating secrets, tokens, or other security-sensitive elements.\n\n## Remediations\n\n- **Do** use `crypto/rand` instead of `math/rand` for generating random numbers in contexts where security is crucial. This ensures the randomness is cryptographically secure and unpredictable.\n- **Do not** use `math/rand` for generating random numbers in cryptographic applications, including but not limited to key generation, authentication tokens, or security challenges.\n- **Do not** initialize `math/rand` with predictable seeds, such as timestamps or other easily guessable values, if it is required to use `math/rand`.\n\n## References\n\n- [crypto/rand package documentation](https://pkg.go.dev/crypto/rand)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_random","line_number":519,"full_filename":"modules/caddyhttp/fileserver/staticfiles.go","filename":"modules/caddyhttp/fileserver/staticfiles.go","category_groups":["PII","Personal Data"],"source":{"start":519,"end":519,"column":{"start":14,"end":50}},"sink":{"start":519,"end":519,"column":{"start":14,"end":50},"content":""},"parent_line_number":519,"fingerprint":"efdd600bf01333043dd7bc56df390541_0","old_fingerprint":"efdd600bf01333043dd7bc56df390541_10","code_extract":"\t\tbackoff := weakrand.Intn(maxBackoff-minBackoff) + minBackoff"},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_random","title":"Usage of weak Pseudo-Random Number Generator (PRNG)","description":"## Description\n\nThe `math/rand` package in Go generates pseudorandom numbers that are not secure for cryptographic purposes. These numbers can be predicted if the seed is known, posing a risk to the security of applications that use them for generating secrets, tokens, or other security-sensitive elements.\n\n## Remediations\n\n- **Do** use `crypto/rand` instead of `math/rand` for generating random numbers in contexts where security is crucial. This ensures the randomness is cryptographically secure and unpredictable.\n- **Do not** use `math/rand` for generating random numbers in cryptographic applications, including but not limited to key generation, authentication tokens, or security challenges.\n- **Do not** initialize `math/rand` with predictable seeds, such as timestamps or other easily guessable values, if it is required to use `math/rand`.\n\n## References\n\n- [crypto/rand package documentation](https://pkg.go.dev/crypto/rand)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_random","line_number":74,"full_filename":"modules/caddyhttp/http2listener.go","filename":"modules/caddyhttp/http2listener.go","category_groups":["PII","Personal Data"],"source":{"start":74,"end":74,"column":{"start":48,"end":87}},"sink":{"start":74,"end":74,"column":{"start":48,"end":87},"content":""},"parent_line_number":74,"fingerprint":"60b6964c8347244a95c9b74e085830b5_0","old_fingerprint":"60b6964c8347244a95c9b74e085830b5_0","code_extract":"\t\tinterval := pollIntervalBase + time.Duration(weakrand.Intn(int(pollIntervalBase/10)))"},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_random","title":"Usage of weak Pseudo-Random Number Generator (PRNG)","description":"## Description\n\nThe `math/rand` package in Go generates pseudorandom numbers that are not secure for cryptographic purposes. These numbers can be predicted if the seed is known, posing a risk to the security of applications that use them for generating secrets, tokens, or other security-sensitive elements.\n\n## Remediations\n\n- **Do** use `crypto/rand` instead of `math/rand` for generating random numbers in contexts where security is crucial. This ensures the randomness is cryptographically secure and unpredictable.\n- **Do not** use `math/rand` for generating random numbers in cryptographic applications, including but not limited to key generation, authentication tokens, or security challenges.\n- **Do not** initialize `math/rand` with predictable seeds, such as timestamps or other easily guessable values, if it is required to use `math/rand`.\n\n## References\n\n- [crypto/rand package documentation](https://pkg.go.dev/crypto/rand)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_random","line_number":176,"full_filename":"modules/caddyhttp/reverseproxy/httptransport.go","filename":"modules/caddyhttp/reverseproxy/httptransport.go","category_groups":["PII","Personal Data"],"source":{"start":176,"end":176,"column":{"start":33,"end":72}},"sink":{"start":176,"end":176,"column":{"start":33,"end":72},"content":""},"parent_line_number":176,"fingerprint":"af0bea402f6c00f278fdac350214cd80_0","old_fingerprint":"af0bea402f6c00f278fdac350214cd80_3","code_extract":"\t\t\t\taddr := h.Resolver.netAddrs[weakrand.Intn(len(h.Resolver.netAddrs))]"},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_random","title":"Usage of weak Pseudo-Random Number Generator (PRNG)","description":"## Description\n\nThe `math/rand` package in Go generates pseudorandom numbers that are not secure for cryptographic purposes. These numbers can be predicted if the seed is known, posing a risk to the security of applications that use them for generating secrets, tokens, or other security-sensitive elements.\n\n## Remediations\n\n- **Do** use `crypto/rand` instead of `math/rand` for generating random numbers in contexts where security is crucial. This ensures the randomness is cryptographically secure and unpredictable.\n- **Do not** use `math/rand` for generating random numbers in cryptographic applications, including but not limited to key generation, authentication tokens, or security challenges.\n- **Do not** initialize `math/rand` with predictable seeds, such as timestamps or other easily guessable values, if it is required to use `math/rand`.\n\n## References\n\n- [crypto/rand package documentation](https://pkg.go.dev/crypto/rand)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_random","line_number":223,"full_filename":"modules/caddyhttp/reverseproxy/selectionpolicies.go","filename":"modules/caddyhttp/reverseproxy/selectionpolicies.go","category_groups":["PII","Personal Data"],"source":{"start":223,"end":223,"column":{"start":8,"end":28}},"sink":{"start":223,"end":223,"column":{"start":8,"end":28},"content":""},"parent_line_number":223,"fingerprint":"8e4e61199e5cdca7e8cbf7d96912ad2e_0","old_fingerprint":"8e4e61199e5cdca7e8cbf7d96912ad2e_4","code_extract":"\t\tj := weakrand.Intn(i + 1) //nolint:gosec"},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_random","title":"Usage of weak Pseudo-Random Number Generator (PRNG)","description":"## Description\n\nThe `math/rand` package in Go generates pseudorandom numbers that are not secure for cryptographic purposes. These numbers can be predicted if the seed is known, posing a risk to the security of applications that use them for generating secrets, tokens, or other security-sensitive elements.\n\n## Remediations\n\n- **Do** use `crypto/rand` instead of `math/rand` for generating random numbers in contexts where security is crucial. This ensures the randomness is cryptographically secure and unpredictable.\n- **Do not** use `math/rand` for generating random numbers in cryptographic applications, including but not limited to key generation, authentication tokens, or security challenges.\n- **Do not** initialize `math/rand` with predictable seeds, such as timestamps or other easily guessable values, if it is required to use `math/rand`.\n\n## References\n\n- [crypto/rand package documentation](https://pkg.go.dev/crypto/rand)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_random","line_number":272,"full_filename":"modules/caddyhttp/reverseproxy/selectionpolicies.go","filename":"modules/caddyhttp/reverseproxy/selectionpolicies.go","category_groups":["PII","Personal Data"],"source":{"start":272,"end":272,"column":{"start":22,"end":36}},"sink":{"start":272,"end":272,"column":{"start":22,"end":36},"content":""},"parent_line_number":272,"fingerprint":"8e4e61199e5cdca7e8cbf7d96912ad2e_1","old_fingerprint":"8e4e61199e5cdca7e8cbf7d96912ad2e_6","code_extract":"\t\t\tif count == 1 || (weakrand.Int()%count) == 0 { //nolint:gosec"},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_random","title":"Usage of weak Pseudo-Random Number Generator (PRNG)","description":"## Description\n\nThe `math/rand` package in Go generates pseudorandom numbers that are not secure for cryptographic purposes. These numbers can be predicted if the seed is known, posing a risk to the security of applications that use them for generating secrets, tokens, or other security-sensitive elements.\n\n## Remediations\n\n- **Do** use `crypto/rand` instead of `math/rand` for generating random numbers in contexts where security is crucial. This ensures the randomness is cryptographically secure and unpredictable.\n- **Do not** use `math/rand` for generating random numbers in cryptographic applications, including but not limited to key generation, authentication tokens, or security challenges.\n- **Do not** initialize `math/rand` with predictable seeds, such as timestamps or other easily guessable values, if it is required to use `math/rand`.\n\n## References\n\n- [crypto/rand package documentation](https://pkg.go.dev/crypto/rand)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_random","line_number":756,"full_filename":"modules/caddyhttp/reverseproxy/selectionpolicies.go","filename":"modules/caddyhttp/reverseproxy/selectionpolicies.go","category_groups":["PII","Personal Data"],"source":{"start":756,"end":756,"column":{"start":7,"end":21}},"sink":{"start":756,"end":756,"column":{"start":7,"end":21},"content":""},"parent_line_number":756,"fingerprint":"8e4e61199e5cdca7e8cbf7d96912ad2e_2","old_fingerprint":"8e4e61199e5cdca7e8cbf7d96912ad2e_11","code_extract":"\t\tif (weakrand.Int() % count) == 0 { //nolint:gosec"},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_random","title":"Usage of weak Pseudo-Random Number Generator (PRNG)","description":"## Description\n\nThe `math/rand` package in Go generates pseudorandom numbers that are not secure for cryptographic purposes. These numbers can be predicted if the seed is known, posing a risk to the security of applications that use them for generating secrets, tokens, or other security-sensitive elements.\n\n## Remediations\n\n- **Do** use `crypto/rand` instead of `math/rand` for generating random numbers in contexts where security is crucial. This ensures the randomness is cryptographically secure and unpredictable.\n- **Do not** use `math/rand` for generating random numbers in cryptographic applications, including but not limited to key generation, authentication tokens, or security challenges.\n- **Do not** initialize `math/rand` with predictable seeds, such as timestamps or other easily guessable values, if it is required to use `math/rand`.\n\n## References\n\n- [crypto/rand package documentation](https://pkg.go.dev/crypto/rand)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_random","line_number":795,"full_filename":"modules/caddyhttp/reverseproxy/selectionpolicies.go","filename":"modules/caddyhttp/reverseproxy/selectionpolicies.go","category_groups":["PII","Personal Data"],"source":{"start":795,"end":795,"column":{"start":14,"end":38}},"sink":{"start":795,"end":795,"column":{"start":14,"end":38},"content":""},"parent_line_number":795,"fingerprint":"8e4e61199e5cdca7e8cbf7d96912ad2e_3","old_fingerprint":"8e4e61199e5cdca7e8cbf7d96912ad2e_12","code_extract":"\treturn best[weakrand.Intn(len(best))] //nolint:gosec"},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_random","title":"Usage of weak Pseudo-Random Number Generator (PRNG)","description":"## Description\n\nThe `math/rand` package in Go generates pseudorandom numbers that are not secure for cryptographic purposes. These numbers can be predicted if the seed is known, posing a risk to the security of applications that use them for generating secrets, tokens, or other security-sensitive elements.\n\n## Remediations\n\n- **Do** use `crypto/rand` instead of `math/rand` for generating random numbers in contexts where security is crucial. This ensures the randomness is cryptographically secure and unpredictable.\n- **Do not** use `math/rand` for generating random numbers in cryptographic applications, including but not limited to key generation, authentication tokens, or security challenges.\n- **Do not** initialize `math/rand` with predictable seeds, such as timestamps or other easily guessable values, if it is required to use `math/rand`.\n\n## References\n\n- [crypto/rand package documentation](https://pkg.go.dev/crypto/rand)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_random","line_number":452,"full_filename":"modules/caddyhttp/reverseproxy/streaming.go","filename":"modules/caddyhttp/reverseproxy/streaming.go","category_groups":["PII","Personal Data"],"source":{"start":452,"end":452,"column":{"start":7,"end":24}},"sink":{"start":452,"end":452,"column":{"start":7,"end":24},"content":""},"parent_line_number":452,"fingerprint":"6f2c92b7d902fa17beda8da0b6bf1360_0","old_fingerprint":"6f2c92b7d902fa17beda8da0b6bf1360_9","code_extract":"\tn := weakrand.Uint32()"},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_random","title":"Usage of weak Pseudo-Random Number Generator (PRNG)","description":"## Description\n\nThe `math/rand` package in Go generates pseudorandom numbers that are not secure for cryptographic purposes. These numbers can be predicted if the seed is known, posing a risk to the security of applications that use them for generating secrets, tokens, or other security-sensitive elements.\n\n## Remediations\n\n- **Do** use `crypto/rand` instead of `math/rand` for generating random numbers in contexts where security is crucial. This ensures the randomness is cryptographically secure and unpredictable.\n- **Do not** use `math/rand` for generating random numbers in cryptographic applications, including but not limited to key generation, authentication tokens, or security challenges.\n- **Do not** initialize `math/rand` with predictable seeds, such as timestamps or other easily guessable values, if it is required to use `math/rand`.\n\n## References\n\n- [crypto/rand package documentation](https://pkg.go.dev/crypto/rand)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_random","line_number":97,"full_filename":"modules/caddyhttp/reverseproxy/upstreams.go","filename":"modules/caddyhttp/reverseproxy/upstreams.go","category_groups":["PII","Personal Data"],"source":{"start":97,"end":97,"column":{"start":34,"end":74}},"sink":{"start":97,"end":97,"column":{"start":34,"end":74},"content":""},"parent_line_number":97,"fingerprint":"4daede001d7b9db3d6214c7c769965df_0","old_fingerprint":"4daede001d7b9db3d6214c7c769965df_1","code_extract":"\t\t\t\taddr := su.Resolver.netAddrs[weakrand.Intn(len(su.Resolver.netAddrs))]"},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_random","title":"Usage of weak Pseudo-Random Number Generator (PRNG)","description":"## Description\n\nThe `math/rand` package in Go generates pseudorandom numbers that are not secure for cryptographic purposes. These numbers can be predicted if the seed is known, posing a risk to the security of applications that use them for generating secrets, tokens, or other security-sensitive elements.\n\n## Remediations\n\n- **Do** use `crypto/rand` instead of `math/rand` for generating random numbers in contexts where security is crucial. This ensures the randomness is cryptographically secure and unpredictable.\n- **Do not** use `math/rand` for generating random numbers in cryptographic applications, including but not limited to key generation, authentication tokens, or security challenges.\n- **Do not** initialize `math/rand` with predictable seeds, such as timestamps or other easily guessable values, if it is required to use `math/rand`.\n\n## References\n\n- [crypto/rand package documentation](https://pkg.go.dev/crypto/rand)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_random","line_number":288,"full_filename":"modules/caddyhttp/reverseproxy/upstreams.go","filename":"modules/caddyhttp/reverseproxy/upstreams.go","category_groups":["PII","Personal Data"],"source":{"start":288,"end":288,"column":{"start":34,"end":74}},"sink":{"start":288,"end":288,"column":{"start":34,"end":74},"content":""},"parent_line_number":288,"fingerprint":"4daede001d7b9db3d6214c7c769965df_1","old_fingerprint":"4daede001d7b9db3d6214c7c769965df_8","code_extract":"\t\t\t\taddr := au.Resolver.netAddrs[weakrand.Intn(len(au.Resolver.netAddrs))]"},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_random","title":"Usage of weak Pseudo-Random Number Generator (PRNG)","description":"## Description\n\nThe `math/rand` package in Go generates pseudorandom numbers that are not secure for cryptographic purposes. These numbers can be predicted if the seed is known, posing a risk to the security of applications that use them for generating secrets, tokens, or other security-sensitive elements.\n\n## Remediations\n\n- **Do** use `crypto/rand` instead of `math/rand` for generating random numbers in contexts where security is crucial. This ensures the randomness is cryptographically secure and unpredictable.\n- **Do not** use `math/rand` for generating random numbers in cryptographic applications, including but not limited to key generation, authentication tokens, or security challenges.\n- **Do not** initialize `math/rand` with predictable seeds, such as timestamps or other easily guessable values, if it is required to use `math/rand`.\n\n## References\n\n- [crypto/rand package documentation](https://pkg.go.dev/crypto/rand)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_random","line_number":286,"full_filename":"modules/caddypki/acmeserver/acmeserver.go","filename":"modules/caddypki/acmeserver/acmeserver.go","category_groups":["PII","Personal Data"],"source":{"start":286,"end":286,"column":{"start":27,"end":60}},"sink":{"start":286,"end":286,"column":{"start":27,"end":60},"content":""},"parent_line_number":286,"fingerprint":"c3debae2121de30e578611db89a0b7e5_0","old_fingerprint":"c3debae2121de30e578611db89a0b7e5_7","code_extract":"\t\t\t\taddr := ash.resolvers[weakrand.Intn(len(ash.resolvers))]"},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_tls_version","title":"Usage of deprecated TLS version","description":"## Description\n\nTLS (Transport Layer Security) versions 1.0 and 1.1 have known vulnerabilities and using them introduces security risks to your application. These outdated TLS versions can lead to the interception and compromise of sensitive data during transmission.\n\n## Remediations\n\n- **Do** enforce the use of TLS 1.3 when configuring Go's TLS library. TLS 1.3 offers significant security improvements, helping to protect data from known vulnerabilities present in older versions.\n  ```go\n    cfg := \u0026tls.Config{\n      MinVersion:   tls.VersionTLS13,\n      ...\n    }\n  ```\n- **Do** utilize configurations that support Perfect Forward Secrecy (PFS) with TLS 1.3. PFS enhances security by ensuring that past communications remain secure even if future session keys are compromised.\n- **Do** regularly update your Go version and dependencies to incorporate the latest security fixes and improvements.\n- **Do not** configure your server to accept TLS versions 1.0 or 1.1. Removing these options from your TLS configuration is crucial to prevent downgrade attacks.\n\n## References\n\n- [IETF's Deprecation of TLS 1.0 and 1.1](https://tools.ietf.org/html/rfc8996)\n- [OWASP TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html)\n- [Go `crypto/tls` package documentation](https://pkg.go.dev/crypto/tls)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_tls_version","line_number":415,"full_filename":"modules/caddyhttp/reverseproxy/fastcgi/fastcgi.go","filename":"modules/caddyhttp/reverseproxy/fastcgi/fastcgi.go","category_groups":["PII","Personal Data"],"source":{"start":415,"end":415,"column":{"start":2,"end":18}},"sink":{"start":415,"end":415,"column":{"start":2,"end":18},"content":""},"parent_line_number":415,"fingerprint":"64fa648846aacfe0b9c6e0331a48d77b_0","old_fingerprint":"64fa648846aacfe0b9c6e0331a48d77b_2","code_extract":"\ttls.VersionTLS10: \"TLSv1\","},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_tls_version","title":"Usage of deprecated TLS version","description":"## Description\n\nTLS (Transport Layer Security) versions 1.0 and 1.1 have known vulnerabilities and using them introduces security risks to your application. These outdated TLS versions can lead to the interception and compromise of sensitive data during transmission.\n\n## Remediations\n\n- **Do** enforce the use of TLS 1.3 when configuring Go's TLS library. TLS 1.3 offers significant security improvements, helping to protect data from known vulnerabilities present in older versions.\n  ```go\n    cfg := \u0026tls.Config{\n      MinVersion:   tls.VersionTLS13,\n      ...\n    }\n  ```\n- **Do** utilize configurations that support Perfect Forward Secrecy (PFS) with TLS 1.3. PFS enhances security by ensuring that past communications remain secure even if future session keys are compromised.\n- **Do** regularly update your Go version and dependencies to incorporate the latest security fixes and improvements.\n- **Do not** configure your server to accept TLS versions 1.0 or 1.1. Removing these options from your TLS configuration is crucial to prevent downgrade attacks.\n\n## References\n\n- [IETF's Deprecation of TLS 1.0 and 1.1](https://tools.ietf.org/html/rfc8996)\n- [OWASP TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html)\n- [Go `crypto/tls` package documentation](https://pkg.go.dev/crypto/tls)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_tls_version","line_number":416,"full_filename":"modules/caddyhttp/reverseproxy/fastcgi/fastcgi.go","filename":"modules/caddyhttp/reverseproxy/fastcgi/fastcgi.go","category_groups":["PII","Personal Data"],"source":{"start":416,"end":416,"column":{"start":2,"end":18}},"sink":{"start":416,"end":416,"column":{"start":2,"end":18},"content":""},"parent_line_number":416,"fingerprint":"64fa648846aacfe0b9c6e0331a48d77b_1","old_fingerprint":"64fa648846aacfe0b9c6e0331a48d77b_3","code_extract":"\ttls.VersionTLS11: \"TLSv1.1\","},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_tls_version","title":"Usage of deprecated TLS version","description":"## Description\n\nTLS (Transport Layer Security) versions 1.0 and 1.1 have known vulnerabilities and using them introduces security risks to your application. These outdated TLS versions can lead to the interception and compromise of sensitive data during transmission.\n\n## Remediations\n\n- **Do** enforce the use of TLS 1.3 when configuring Go's TLS library. TLS 1.3 offers significant security improvements, helping to protect data from known vulnerabilities present in older versions.\n  ```go\n    cfg := \u0026tls.Config{\n      MinVersion:   tls.VersionTLS13,\n      ...\n    }\n  ```\n- **Do** utilize configurations that support Perfect Forward Secrecy (PFS) with TLS 1.3. PFS enhances security by ensuring that past communications remain secure even if future session keys are compromised.\n- **Do** regularly update your Go version and dependencies to incorporate the latest security fixes and improvements.\n- **Do not** configure your server to accept TLS versions 1.0 or 1.1. Removing these options from your TLS configuration is crucial to prevent downgrade attacks.\n\n## References\n\n- [IETF's Deprecation of TLS 1.0 and 1.1](https://tools.ietf.org/html/rfc8996)\n- [OWASP TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html)\n- [Go `crypto/tls` package documentation](https://pkg.go.dev/crypto/tls)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_tls_version","line_number":127,"full_filename":"modules/caddytls/values.go","filename":"modules/caddytls/values.go","category_groups":["PII","Personal Data"],"source":{"start":127,"end":127,"column":{"start":12,"end":28}},"sink":{"start":127,"end":127,"column":{"start":12,"end":28},"content":""},"parent_line_number":127,"fingerprint":"1e66aeb41a37e1bf7f522d85c3f3f5e5_0","old_fingerprint":"1e66aeb41a37e1bf7f522d85c3f3f5e5_0","code_extract":"\t\"tls1.0\": tls.VersionTLS10,"},{"cwe_ids":["327"],"id":"go_gosec_crypto_weak_tls_version","title":"Usage of deprecated TLS version","description":"## Description\n\nTLS (Transport Layer Security) versions 1.0 and 1.1 have known vulnerabilities and using them introduces security risks to your application. These outdated TLS versions can lead to the interception and compromise of sensitive data during transmission.\n\n## Remediations\n\n- **Do** enforce the use of TLS 1.3 when configuring Go's TLS library. TLS 1.3 offers significant security improvements, helping to protect data from known vulnerabilities present in older versions.\n  ```go\n    cfg := \u0026tls.Config{\n      MinVersion:   tls.VersionTLS13,\n      ...\n    }\n  ```\n- **Do** utilize configurations that support Perfect Forward Secrecy (PFS) with TLS 1.3. PFS enhances security by ensuring that past communications remain secure even if future session keys are compromised.\n- **Do** regularly update your Go version and dependencies to incorporate the latest security fixes and improvements.\n- **Do not** configure your server to accept TLS versions 1.0 or 1.1. Removing these options from your TLS configuration is crucial to prevent downgrade attacks.\n\n## References\n\n- [IETF's Deprecation of TLS 1.0 and 1.1](https://tools.ietf.org/html/rfc8996)\n- [OWASP TLS Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Transport_Layer_Security_Cheat_Sheet.html)\n- [Go `crypto/tls` package documentation](https://pkg.go.dev/crypto/tls)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_crypto_weak_tls_version","line_number":128,"full_filename":"modules/caddytls/values.go","filename":"modules/caddytls/values.go","category_groups":["PII","Personal Data"],"source":{"start":128,"end":128,"column":{"start":12,"end":28}},"sink":{"start":128,"end":128,"column":{"start":12,"end":28},"content":""},"parent_line_number":128,"fingerprint":"1e66aeb41a37e1bf7f522d85c3f3f5e5_1","old_fingerprint":"1e66aeb41a37e1bf7f522d85c3f3f5e5_1","code_extract":"\t\"tls1.1\": tls.VersionTLS11,"},{"cwe_ids":["732"],"id":"go_gosec_file_permissions_file_perm","title":"Permissive file assignment","description":"## Description\n\nSetting overly permissive file permissions exposes your system to risks such as unauthorized access, data tampering, and potential system compromise. This vulnerability arises when files are created or updated without adequately restrictive permissions, allowing unauthorized users to read, modify, or execute files.\n\n## Remediations\n\n- **Do not** use overly permissive file permissions, such as `0777`, which grants read, write, and execute permissions to all users.\n- **Do** set file permissions to restrict access appropriately:\n  - `0400` for read-only access by the file's owner.\n  - `0200` for write-only access by the file's owner.\n  - `0600` for read and write access by the file's owner, suitable for files that the application needs to read from and write to.\n- **Do** use Go's `os` package to manage file permissions effectively. For example, use `os.OpenFile` with appropriate permission flags such as 0600.\n  ```go\n    f, err := os.OpenFile(\"file.txt\", os.O_CREATE|os.O_WRONLY, 0600)\n    ...\n  ```\n- **Do** verify file permissions after creation or update to ensure they are set as intended.\n- **Do** consider setting umask to a secure default, if your application creates multiple files, to ensure that files are created with safe default permissions.\n- **Do** regularly review and audit file permissions in your system to ensure they adhere to the principle of least privilege, minimizing the access level to what is strictly necessary for operational functionality.","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_file_permissions_file_perm","line_number":130,"full_filename":"modules/logging/filewriter.go","filename":"modules/logging/filewriter.go","category_groups":["PII","Personal Data"],"source":{"start":130,"end":130,"column":{"start":9,"end":77}},"sink":{"start":130,"end":130,"column":{"start":9,"end":77},"content":""},"parent_line_number":130,"fingerprint":"f36fe0ac1fe6d5a809441f1b9316c1fc_0","old_fingerprint":"f36fe0ac1fe6d5a809441f1b9316c1fc_0","code_extract":"\treturn os.OpenFile(fw.Filename, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0o666)"},{"cwe_ids":["73"],"id":"go_gosec_filesystem_filereadtaint","title":"Unsanitized user input in file path","description":"## Description\n\nUsing user input to dynamically construct file paths without proper sanitization introduces a high security risk. This practice can allow attackers to manipulate file paths to access or alter sensitive files, potentially leading to data breaches or system compromise. It is essential to sanitize user input before using it in file system operations to prevent path traversal attacks.\n\n## Remediations\n\n- **Do not** use unsanitized user input directly in file path construction. This can lead to path traversal vulnerabilities.\n- **Do** hash or replace user input with a system-generated unique identifier when constructing file paths. This approach minimizes the risk of path manipulation.\n- **Do** use `filepath.Base` to extract the filename from a path, discarding any directory information. This helps prevent directory traversal attacks.\n  ```go\n  safeFilename := filepath.Base(userInput)\n  ```\n- **Do** validate paths before accessing files to ensure they are within the intended directory. This validation acts as a safeguard against unauthorized file access.\n\n## References\n\n- [OWASP Guide to Preventing Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_filesystem_filereadtaint","line_number":521,"full_filename":"caddyconfig/caddyfile/parse.go","filename":"caddyconfig/caddyfile/parse.go","category_groups":["PII","Personal Data"],"source":{"start":521,"end":521,"column":{"start":15,"end":34}},"sink":{"start":521,"end":521,"column":{"start":15,"end":34},"content":""},"parent_line_number":521,"fingerprint":"f6c7c7418e000a2a2399addb3d2edefa_0","old_fingerprint":"f6c7c7418e000a2a2399addb3d2edefa_2","code_extract":"\tfile, err := os.Open(importFile)"},{"cwe_ids":["73"],"id":"go_gosec_filesystem_filereadtaint","title":"Unsanitized user input in file path","description":"## Description\n\nUsing user input to dynamically construct file paths without proper sanitization introduces a high security risk. This practice can allow attackers to manipulate file paths to access or alter sensitive files, potentially leading to data breaches or system compromise. It is essential to sanitize user input before using it in file system operations to prevent path traversal attacks.\n\n## Remediations\n\n- **Do not** use unsanitized user input directly in file path construction. This can lead to path traversal vulnerabilities.\n- **Do** hash or replace user input with a system-generated unique identifier when constructing file paths. This approach minimizes the risk of path manipulation.\n- **Do** use `filepath.Base` to extract the filename from a path, discarding any directory information. This helps prevent directory traversal attacks.\n  ```go\n  safeFilename := filepath.Base(userInput)\n  ```\n- **Do** validate paths before accessing files to ensure they are within the intended directory. This validation acts as a safeguard against unauthorized file access.\n\n## References\n\n- [OWASP Guide to Preventing Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_filesystem_filereadtaint","line_number":293,"full_filename":"cmd/packagesfuncs.go","filename":"cmd/packagesfuncs.go","category_groups":["PII","Personal Data"],"source":{"start":293,"end":293,"column":{"start":19,"end":87}},"sink":{"start":293,"end":293,"column":{"start":19,"end":87},"content":""},"parent_line_number":293,"fingerprint":"30ea9811ca86f74b10654570ce7daaad_0","old_fingerprint":"30ea9811ca86f74b10654570ce7daaad_0","code_extract":"\tdestFile, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, fileInfo.Mode())"},{"cwe_ids":["73"],"id":"go_gosec_filesystem_filereadtaint","title":"Unsanitized user input in file path","description":"## Description\n\nUsing user input to dynamically construct file paths without proper sanitization introduces a high security risk. This practice can allow attackers to manipulate file paths to access or alter sensitive files, potentially leading to data breaches or system compromise. It is essential to sanitize user input before using it in file system operations to prevent path traversal attacks.\n\n## Remediations\n\n- **Do not** use unsanitized user input directly in file path construction. This can lead to path traversal vulnerabilities.\n- **Do** hash or replace user input with a system-generated unique identifier when constructing file paths. This approach minimizes the risk of path manipulation.\n- **Do** use `filepath.Base` to extract the filename from a path, discarding any directory information. This helps prevent directory traversal attacks.\n  ```go\n  safeFilename := filepath.Base(userInput)\n  ```\n- **Do** validate paths before accessing files to ensure they are within the intended directory. This validation acts as a safeguard against unauthorized file access.\n\n## References\n\n- [OWASP Guide to Preventing Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_filesystem_filereadtaint","line_number":685,"full_filename":"modules/caddyhttp/fileserver/staticfiles.go","filename":"modules/caddyhttp/fileserver/staticfiles.go","category_groups":["PII","Personal Data"],"source":{"start":685,"end":685,"column":{"start":66,"end":79}},"sink":{"start":685,"end":685,"column":{"start":66,"end":79},"content":""},"parent_line_number":685,"fingerprint":"a88cd92b12748924d112114a9e062f70_0","old_fingerprint":"a88cd92b12748924d112114a9e062f70_3","code_extract":"func (osFS) Open(name string) (fs.File, error)          { return os.Open(name) }"},{"cwe_ids":["73"],"id":"go_gosec_filesystem_filereadtaint","title":"Unsanitized user input in file path","description":"## Description\n\nUsing user input to dynamically construct file paths without proper sanitization introduces a high security risk. This practice can allow attackers to manipulate file paths to access or alter sensitive files, potentially leading to data breaches or system compromise. It is essential to sanitize user input before using it in file system operations to prevent path traversal attacks.\n\n## Remediations\n\n- **Do not** use unsanitized user input directly in file path construction. This can lead to path traversal vulnerabilities.\n- **Do** hash or replace user input with a system-generated unique identifier when constructing file paths. This approach minimizes the risk of path manipulation.\n- **Do** use `filepath.Base` to extract the filename from a path, discarding any directory information. This helps prevent directory traversal attacks.\n  ```go\n  safeFilename := filepath.Base(userInput)\n  ```\n- **Do** validate paths before accessing files to ensure they are within the intended directory. This validation acts as a safeguard against unauthorized file access.\n\n## References\n\n- [OWASP Guide to Preventing Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_filesystem_filereadtaint","line_number":689,"full_filename":"modules/caddyhttp/fileserver/staticfiles.go","filename":"modules/caddyhttp/fileserver/staticfiles.go","category_groups":["PII","Personal Data"],"source":{"start":689,"end":689,"column":{"start":66,"end":83}},"sink":{"start":689,"end":689,"column":{"start":66,"end":83},"content":""},"parent_line_number":689,"fingerprint":"a88cd92b12748924d112114a9e062f70_1","old_fingerprint":"a88cd92b12748924d112114a9e062f70_4","code_extract":"func (osFS) ReadFile(name string) ([]byte, error)       { return os.ReadFile(name) }"},{"cwe_ids":["73"],"id":"go_gosec_filesystem_filereadtaint","title":"Unsanitized user input in file path","description":"## Description\n\nUsing user input to dynamically construct file paths without proper sanitization introduces a high security risk. This practice can allow attackers to manipulate file paths to access or alter sensitive files, potentially leading to data breaches or system compromise. It is essential to sanitize user input before using it in file system operations to prevent path traversal attacks.\n\n## Remediations\n\n- **Do not** use unsanitized user input directly in file path construction. This can lead to path traversal vulnerabilities.\n- **Do** hash or replace user input with a system-generated unique identifier when constructing file paths. This approach minimizes the risk of path manipulation.\n- **Do** use `filepath.Base` to extract the filename from a path, discarding any directory information. This helps prevent directory traversal attacks.\n  ```go\n  safeFilename := filepath.Base(userInput)\n  ```\n- **Do** validate paths before accessing files to ensure they are within the intended directory. This validation acts as a safeguard against unauthorized file access.\n\n## References\n\n- [OWASP Guide to Preventing Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_filesystem_filereadtaint","line_number":324,"full_filename":"modules/caddyhttp/reverseproxy/fastcgi/client.go","filename":"modules/caddyhttp/reverseproxy/fastcgi/client.go","category_groups":["PII","Personal Data"],"source":{"start":324,"end":324,"column":{"start":12,"end":24}},"sink":{"start":324,"end":324,"column":{"start":12,"end":24},"content":""},"parent_line_number":324,"fingerprint":"d3708f29ef97e3637cd3fc88b7f2e329_0","old_fingerprint":"d3708f29ef97e3637cd3fc88b7f2e329_1","code_extract":"\t\tfd, e := os.Open(val)"},{"cwe_ids":["918"],"id":"go_gosec_injection_ssrf_injection","title":"Unsanitized user input in HTTP request (SSRF)","description":"## Description\n\nIncluding unsanitized user input in HTTP requests puts your application at risk of Server-Side Request Forgery (SSRF). This is a security vulnerability that occurs when a server-side application makes HTTP requests to arbitrary URLs controlled by the user. SSRF can be exploited by attackers to target internal systems behind firewalls that are otherwise inaccessible from the external network, by tricking the server into making requests to these systems.\n\n## Remediations\n\n- **Do not** use direct user input to construct URLs for backend requests. If user input is necessary, ensure it is strictly validated or sanitized to prevent malicious manipulation.\n- **Do** use a safelist or predefined mapping when incorporating user input in URLs. This ensures that your application only redirects users to safe and intended destinations.\n  ```go\n  safeURLs := map[string]string{\n      \"key1\": \"https://safe-domain1.com\",\n      \"key2\": \"https://safe-domain2.com\",\n  }\n  requestedKey := getUserInput()\n  if url, ok := safeURLs[requestedKey]; ok {\n      // continue with request\n  } else {\n      log.Fatal(\"Requested URL is not allowed\")\n  }\n  ```\n- **Do** implement IP safelists and blocklists to customize and block specific IP ranges, especially those that are private, loopback, or otherwise non-routable.\n- **Do** use network-level security measures. If your HTTP client does not support IP range blocking, run it with restricted system permissions or within a network environment where firewall rules can effectively block requests to dangerous addresses.\n- **Do** consider using a secure HTTP proxy to route all backend HTTP requests. This proxy can serve as a filter to block requests to potentially harmful addresses, acting as an additional layer of security.\n\n## References\n\n- [OWASP SSRF Prevention Cheat Sheet](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_injection_ssrf_injection","line_number":143,"full_filename":"caddytest/caddytest.go","filename":"caddytest/caddytest.go","category_groups":["PII","Personal Data"],"source":{"start":143,"end":143,"column":{"start":14,"end":127}},"sink":{"start":143,"end":143,"column":{"start":14,"end":127},"content":""},"parent_line_number":143,"fingerprint":"fbb2c6f630605e32cac967f596938942_0","old_fingerprint":"fbb2c6f630605e32cac967f596938942_0","code_extract":"\treq, err := http.NewRequest(\"POST\", fmt.Sprintf(\"http://localhost:%d/load\", Default.AdminPort), strings.NewReader(rawConfig))"},{"cwe_ids":["918"],"id":"go_gosec_injection_ssrf_injection","title":"Unsanitized user input in HTTP request (SSRF)","description":"## Description\n\nIncluding unsanitized user input in HTTP requests puts your application at risk of Server-Side Request Forgery (SSRF). This is a security vulnerability that occurs when a server-side application makes HTTP requests to arbitrary URLs controlled by the user. SSRF can be exploited by attackers to target internal systems behind firewalls that are otherwise inaccessible from the external network, by tricking the server into making requests to these systems.\n\n## Remediations\n\n- **Do not** use direct user input to construct URLs for backend requests. If user input is necessary, ensure it is strictly validated or sanitized to prevent malicious manipulation.\n- **Do** use a safelist or predefined mapping when incorporating user input in URLs. This ensures that your application only redirects users to safe and intended destinations.\n  ```go\n  safeURLs := map[string]string{\n      \"key1\": \"https://safe-domain1.com\",\n      \"key2\": \"https://safe-domain2.com\",\n  }\n  requestedKey := getUserInput()\n  if url, ok := safeURLs[requestedKey]; ok {\n      // continue with request\n  } else {\n      log.Fatal(\"Requested URL is not allowed\")\n  }\n  ```\n- **Do** implement IP safelists and blocklists to customize and block specific IP ranges, especially those that are private, loopback, or otherwise non-routable.\n- **Do** use network-level security measures. If your HTTP client does not support IP range blocking, run it with restricted system permissions or within a network environment where firewall rules can effectively block requests to dangerous addresses.\n- **Do** consider using a secure HTTP proxy to route all backend HTTP requests. This proxy can serve as a filter to block requests to potentially harmful addresses, acting as an additional layer of security.\n\n## References\n\n- [OWASP SSRF Prevention Cheat Sheet](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_injection_ssrf_injection","line_number":499,"full_filename":"caddytest/caddytest.go","filename":"caddytest/caddytest.go","category_groups":["PII","Personal Data"],"source":{"start":499,"end":499,"column":{"start":14,"end":53}},"sink":{"start":499,"end":499,"column":{"start":14,"end":53},"content":""},"parent_line_number":499,"fingerprint":"fbb2c6f630605e32cac967f596938942_1","old_fingerprint":"fbb2c6f630605e32cac967f596938942_3","code_extract":"\treq, err := http.NewRequest(\"GET\", requestURI, nil)"},{"cwe_ids":["918"],"id":"go_gosec_injection_ssrf_injection","title":"Unsanitized user input in HTTP request (SSRF)","description":"## Description\n\nIncluding unsanitized user input in HTTP requests puts your application at risk of Server-Side Request Forgery (SSRF). This is a security vulnerability that occurs when a server-side application makes HTTP requests to arbitrary URLs controlled by the user. SSRF can be exploited by attackers to target internal systems behind firewalls that are otherwise inaccessible from the external network, by tricking the server into making requests to these systems.\n\n## Remediations\n\n- **Do not** use direct user input to construct URLs for backend requests. If user input is necessary, ensure it is strictly validated or sanitized to prevent malicious manipulation.\n- **Do** use a safelist or predefined mapping when incorporating user input in URLs. This ensures that your application only redirects users to safe and intended destinations.\n  ```go\n  safeURLs := map[string]string{\n      \"key1\": \"https://safe-domain1.com\",\n      \"key2\": \"https://safe-domain2.com\",\n  }\n  requestedKey := getUserInput()\n  if url, ok := safeURLs[requestedKey]; ok {\n      // continue with request\n  } else {\n      log.Fatal(\"Requested URL is not allowed\")\n  }\n  ```\n- **Do** implement IP safelists and blocklists to customize and block specific IP ranges, especially those that are private, loopback, or otherwise non-routable.\n- **Do** use network-level security measures. If your HTTP client does not support IP range blocking, run it with restricted system permissions or within a network environment where firewall rules can effectively block requests to dangerous addresses.\n- **Do** consider using a secure HTTP proxy to route all backend HTTP requests. This proxy can serve as a filter to block requests to potentially harmful addresses, acting as an additional layer of security.\n\n## References\n\n- [OWASP SSRF Prevention Cheat Sheet](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_injection_ssrf_injection","line_number":509,"full_filename":"caddytest/caddytest.go","filename":"caddytest/caddytest.go","category_groups":["PII","Personal Data"],"source":{"start":509,"end":509,"column":{"start":14,"end":56}},"sink":{"start":509,"end":509,"column":{"start":14,"end":56},"content":""},"parent_line_number":509,"fingerprint":"fbb2c6f630605e32cac967f596938942_2","old_fingerprint":"fbb2c6f630605e32cac967f596938942_4","code_extract":"\treq, err := http.NewRequest(\"DELETE\", requestURI, nil)"},{"cwe_ids":["918"],"id":"go_gosec_injection_ssrf_injection","title":"Unsanitized user input in HTTP request (SSRF)","description":"## Description\n\nIncluding unsanitized user input in HTTP requests puts your application at risk of Server-Side Request Forgery (SSRF). This is a security vulnerability that occurs when a server-side application makes HTTP requests to arbitrary URLs controlled by the user. SSRF can be exploited by attackers to target internal systems behind firewalls that are otherwise inaccessible from the external network, by tricking the server into making requests to these systems.\n\n## Remediations\n\n- **Do not** use direct user input to construct URLs for backend requests. If user input is necessary, ensure it is strictly validated or sanitized to prevent malicious manipulation.\n- **Do** use a safelist or predefined mapping when incorporating user input in URLs. This ensures that your application only redirects users to safe and intended destinations.\n  ```go\n  safeURLs := map[string]string{\n      \"key1\": \"https://safe-domain1.com\",\n      \"key2\": \"https://safe-domain2.com\",\n  }\n  requestedKey := getUserInput()\n  if url, ok := safeURLs[requestedKey]; ok {\n      // continue with request\n  } else {\n      log.Fatal(\"Requested URL is not allowed\")\n  }\n  ```\n- **Do** implement IP safelists and blocklists to customize and block specific IP ranges, especially those that are private, loopback, or otherwise non-routable.\n- **Do** use network-level security measures. If your HTTP client does not support IP range blocking, run it with restricted system permissions or within a network environment where firewall rules can effectively block requests to dangerous addresses.\n- **Do** consider using a secure HTTP proxy to route all backend HTTP requests. This proxy can serve as a filter to block requests to potentially harmful addresses, acting as an additional layer of security.\n\n## References\n\n- [OWASP SSRF Prevention Cheat Sheet](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_injection_ssrf_injection","line_number":519,"full_filename":"caddytest/caddytest.go","filename":"caddytest/caddytest.go","category_groups":["PII","Personal Data"],"source":{"start":519,"end":519,"column":{"start":14,"end":62}},"sink":{"start":519,"end":519,"column":{"start":14,"end":62},"content":""},"parent_line_number":519,"fingerprint":"fbb2c6f630605e32cac967f596938942_3","old_fingerprint":"fbb2c6f630605e32cac967f596938942_5","code_extract":"\treq, err := http.NewRequest(\"POST\", requestURI, requestBody)"},{"cwe_ids":["918"],"id":"go_gosec_injection_ssrf_injection","title":"Unsanitized user input in HTTP request (SSRF)","description":"## Description\n\nIncluding unsanitized user input in HTTP requests puts your application at risk of Server-Side Request Forgery (SSRF). This is a security vulnerability that occurs when a server-side application makes HTTP requests to arbitrary URLs controlled by the user. SSRF can be exploited by attackers to target internal systems behind firewalls that are otherwise inaccessible from the external network, by tricking the server into making requests to these systems.\n\n## Remediations\n\n- **Do not** use direct user input to construct URLs for backend requests. If user input is necessary, ensure it is strictly validated or sanitized to prevent malicious manipulation.\n- **Do** use a safelist or predefined mapping when incorporating user input in URLs. This ensures that your application only redirects users to safe and intended destinations.\n  ```go\n  safeURLs := map[string]string{\n      \"key1\": \"https://safe-domain1.com\",\n      \"key2\": \"https://safe-domain2.com\",\n  }\n  requestedKey := getUserInput()\n  if url, ok := safeURLs[requestedKey]; ok {\n      // continue with request\n  } else {\n      log.Fatal(\"Requested URL is not allowed\")\n  }\n  ```\n- **Do** implement IP safelists and blocklists to customize and block specific IP ranges, especially those that are private, loopback, or otherwise non-routable.\n- **Do** use network-level security measures. If your HTTP client does not support IP range blocking, run it with restricted system permissions or within a network environment where firewall rules can effectively block requests to dangerous addresses.\n- **Do** consider using a secure HTTP proxy to route all backend HTTP requests. This proxy can serve as a filter to block requests to potentially harmful addresses, acting as an additional layer of security.\n\n## References\n\n- [OWASP SSRF Prevention Cheat Sheet](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_injection_ssrf_injection","line_number":532,"full_filename":"caddytest/caddytest.go","filename":"caddytest/caddytest.go","category_groups":["PII","Personal Data"],"source":{"start":532,"end":532,"column":{"start":14,"end":61}},"sink":{"start":532,"end":532,"column":{"start":14,"end":61},"content":""},"parent_line_number":532,"fingerprint":"fbb2c6f630605e32cac967f596938942_4","old_fingerprint":"fbb2c6f630605e32cac967f596938942_6","code_extract":"\treq, err := http.NewRequest(\"PUT\", requestURI, requestBody)"},{"cwe_ids":["918"],"id":"go_gosec_injection_ssrf_injection","title":"Unsanitized user input in HTTP request (SSRF)","description":"## Description\n\nIncluding unsanitized user input in HTTP requests puts your application at risk of Server-Side Request Forgery (SSRF). This is a security vulnerability that occurs when a server-side application makes HTTP requests to arbitrary URLs controlled by the user. SSRF can be exploited by attackers to target internal systems behind firewalls that are otherwise inaccessible from the external network, by tricking the server into making requests to these systems.\n\n## Remediations\n\n- **Do not** use direct user input to construct URLs for backend requests. If user input is necessary, ensure it is strictly validated or sanitized to prevent malicious manipulation.\n- **Do** use a safelist or predefined mapping when incorporating user input in URLs. This ensures that your application only redirects users to safe and intended destinations.\n  ```go\n  safeURLs := map[string]string{\n      \"key1\": \"https://safe-domain1.com\",\n      \"key2\": \"https://safe-domain2.com\",\n  }\n  requestedKey := getUserInput()\n  if url, ok := safeURLs[requestedKey]; ok {\n      // continue with request\n  } else {\n      log.Fatal(\"Requested URL is not allowed\")\n  }\n  ```\n- **Do** implement IP safelists and blocklists to customize and block specific IP ranges, especially those that are private, loopback, or otherwise non-routable.\n- **Do** use network-level security measures. If your HTTP client does not support IP range blocking, run it with restricted system permissions or within a network environment where firewall rules can effectively block requests to dangerous addresses.\n- **Do** consider using a secure HTTP proxy to route all backend HTTP requests. This proxy can serve as a filter to block requests to potentially harmful addresses, acting as an additional layer of security.\n\n## References\n\n- [OWASP SSRF Prevention Cheat Sheet](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_injection_ssrf_injection","line_number":545,"full_filename":"caddytest/caddytest.go","filename":"caddytest/caddytest.go","category_groups":["PII","Personal Data"],"source":{"start":545,"end":545,"column":{"start":14,"end":63}},"sink":{"start":545,"end":545,"column":{"start":14,"end":63},"content":""},"parent_line_number":545,"fingerprint":"fbb2c6f630605e32cac967f596938942_5","old_fingerprint":"fbb2c6f630605e32cac967f596938942_7","code_extract":"\treq, err := http.NewRequest(\"PATCH\", requestURI, requestBody)"},{"cwe_ids":["918"],"id":"go_gosec_injection_ssrf_injection","title":"Unsanitized user input in HTTP request (SSRF)","description":"## Description\n\nIncluding unsanitized user input in HTTP requests puts your application at risk of Server-Side Request Forgery (SSRF). This is a security vulnerability that occurs when a server-side application makes HTTP requests to arbitrary URLs controlled by the user. SSRF can be exploited by attackers to target internal systems behind firewalls that are otherwise inaccessible from the external network, by tricking the server into making requests to these systems.\n\n## Remediations\n\n- **Do not** use direct user input to construct URLs for backend requests. If user input is necessary, ensure it is strictly validated or sanitized to prevent malicious manipulation.\n- **Do** use a safelist or predefined mapping when incorporating user input in URLs. This ensures that your application only redirects users to safe and intended destinations.\n  ```go\n  safeURLs := map[string]string{\n      \"key1\": \"https://safe-domain1.com\",\n      \"key2\": \"https://safe-domain2.com\",\n  }\n  requestedKey := getUserInput()\n  if url, ok := safeURLs[requestedKey]; ok {\n      // continue with request\n  } else {\n      log.Fatal(\"Requested URL is not allowed\")\n  }\n  ```\n- **Do** implement IP safelists and blocklists to customize and block specific IP ranges, especially those that are private, loopback, or otherwise non-routable.\n- **Do** use network-level security measures. If your HTTP client does not support IP range blocking, run it with restricted system permissions or within a network environment where firewall rules can effectively block requests to dangerous addresses.\n- **Do** consider using a secure HTTP proxy to route all backend HTTP requests. This proxy can serve as a filter to block requests to potentially harmful addresses, acting as an additional layer of security.\n\n## References\n\n- [OWASP SSRF Prevention Cheat Sheet](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_injection_ssrf_injection","line_number":662,"full_filename":"cmd/commandfuncs.go","filename":"cmd/commandfuncs.go","category_groups":["PII","Personal Data"],"source":{"start":662,"end":662,"column":{"start":14,"end":55}},"sink":{"start":662,"end":662,"column":{"start":14,"end":55},"content":""},"parent_line_number":662,"fingerprint":"5572bc8866c835514f4f691f492bb53e_0","old_fingerprint":"5572bc8866c835514f4f691f492bb53e_8","code_extract":"\treq, err := http.NewRequest(method, origin+uri, body)"},{"cwe_ids":["918"],"id":"go_gosec_injection_ssrf_injection","title":"Unsanitized user input in HTTP request (SSRF)","description":"## Description\n\nIncluding unsanitized user input in HTTP requests puts your application at risk of Server-Side Request Forgery (SSRF). This is a security vulnerability that occurs when a server-side application makes HTTP requests to arbitrary URLs controlled by the user. SSRF can be exploited by attackers to target internal systems behind firewalls that are otherwise inaccessible from the external network, by tricking the server into making requests to these systems.\n\n## Remediations\n\n- **Do not** use direct user input to construct URLs for backend requests. If user input is necessary, ensure it is strictly validated or sanitized to prevent malicious manipulation.\n- **Do** use a safelist or predefined mapping when incorporating user input in URLs. This ensures that your application only redirects users to safe and intended destinations.\n  ```go\n  safeURLs := map[string]string{\n      \"key1\": \"https://safe-domain1.com\",\n      \"key2\": \"https://safe-domain2.com\",\n  }\n  requestedKey := getUserInput()\n  if url, ok := safeURLs[requestedKey]; ok {\n      // continue with request\n  } else {\n      log.Fatal(\"Requested URL is not allowed\")\n  }\n  ```\n- **Do** implement IP safelists and blocklists to customize and block specific IP ranges, especially those that are private, loopback, or otherwise non-routable.\n- **Do** use network-level security measures. If your HTTP client does not support IP range blocking, run it with restricted system permissions or within a network environment where firewall rules can effectively block requests to dangerous addresses.\n- **Do** consider using a secure HTTP proxy to route all backend HTTP requests. This proxy can serve as a filter to block requests to potentially harmful addresses, acting as an additional layer of security.\n\n## References\n\n- [OWASP SSRF Prevention Cheat Sheet](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_injection_ssrf_injection","line_number":258,"full_filename":"cmd/packagesfuncs.go","filename":"cmd/packagesfuncs.go","category_groups":["PII","Personal Data"],"source":{"start":258,"end":258,"column":{"start":15,"end":72}},"sink":{"start":258,"end":258,"column":{"start":15,"end":72},"content":""},"parent_line_number":258,"fingerprint":"6535b130450f9a841ef3c530a585feab_0","old_fingerprint":"6535b130450f9a841ef3c530a585feab_2","code_extract":"\tresp, err := http.Get(fmt.Sprintf(\"%s?%s\", downloadPath, qs.Encode()))"},{"cwe_ids":["918"],"id":"go_gosec_injection_ssrf_injection","title":"Unsanitized user input in HTTP request (SSRF)","description":"## Description\n\nIncluding unsanitized user input in HTTP requests puts your application at risk of Server-Side Request Forgery (SSRF). This is a security vulnerability that occurs when a server-side application makes HTTP requests to arbitrary URLs controlled by the user. SSRF can be exploited by attackers to target internal systems behind firewalls that are otherwise inaccessible from the external network, by tricking the server into making requests to these systems.\n\n## Remediations\n\n- **Do not** use direct user input to construct URLs for backend requests. If user input is necessary, ensure it is strictly validated or sanitized to prevent malicious manipulation.\n- **Do** use a safelist or predefined mapping when incorporating user input in URLs. This ensures that your application only redirects users to safe and intended destinations.\n  ```go\n  safeURLs := map[string]string{\n      \"key1\": \"https://safe-domain1.com\",\n      \"key2\": \"https://safe-domain2.com\",\n  }\n  requestedKey := getUserInput()\n  if url, ok := safeURLs[requestedKey]; ok {\n      // continue with request\n  } else {\n      log.Fatal(\"Requested URL is not allowed\")\n  }\n  ```\n- **Do** implement IP safelists and blocklists to customize and block specific IP ranges, especially those that are private, loopback, or otherwise non-routable.\n- **Do** use network-level security measures. If your HTTP client does not support IP range blocking, run it with restricted system permissions or within a network environment where firewall rules can effectively block requests to dangerous addresses.\n- **Do** consider using a secure HTTP proxy to route all backend HTTP requests. This proxy can serve as a filter to block requests to potentially harmful addresses, acting as an additional layer of security.\n\n## References\n\n- [OWASP SSRF Prevention Cheat Sheet](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_injection_ssrf_injection","line_number":186,"full_filename":"modules/caddyhttp/templates/tplcontext.go","filename":"modules/caddyhttp/templates/tplcontext.go","category_groups":["PII","Personal Data"],"source":{"start":186,"end":186,"column":{"start":18,"end":50}},"sink":{"start":186,"end":186,"column":{"start":18,"end":50},"content":""},"parent_line_number":186,"fingerprint":"bf8daa563737991f644731714aed0d0e_0","old_fingerprint":"bf8daa563737991f644731714aed0d0e_1","code_extract":"\tvirtReq, err := http.NewRequest(\"GET\", uri, nil)"},{"cwe_ids":["242"],"id":"go_gosec_unsafe_unsafe","title":"Usage of vulnerable 'unsafe' package","description":"## Description\n\nThe `unsafe` package in Go allows for low-level memory management, including direct memory access and pointer manipulation. While `unsafe` is a powerful library, using it bypasses Go's type safety checks and opens the door to security vulnerabilities and unpredictable behavior in your application.\n\n## Remediations\n\n- **Do not** use the `unsafe` package unless it is absolutely necessary. If you must use it, ensure you fully understand the implications and thoroughly test your code.\n- **Do** ensure buffer boundaries are respected to avoid buffer overflows. This precaution helps prevent unauthorized code execution.\n  ```go\n  buffer := make([]byte, 10)\n  ```\n- **Do not** access memory after it has been freed to avoid use-after-free vulnerabilities, which can lead to unintended code execution or unpredictable system behavior.\n  ```go\n  unsafePointer := unsafe.Pointer(\u0026data)\n  C.free(unsafePointer)\n  // now unsafe to access\n  ```\n- **Do** regularly review and audit your code to prevent memory or information leaks that could compromise security or lead to system failures due to exhausted memory.\n\n## References\n\n- [Buffer Overflows - OWASP](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [Using Freed Memory - OWASP](https://owasp.org/www-community/vulnerabilities/Using_freed_memory)\n- [Memory Leaks - OWASP](https://owasp.org/www-community/vulnerabilities/Memory_leak)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_unsafe_unsafe","line_number":418,"full_filename":"modules/caddyhttp/reverseproxy/streaming.go","filename":"modules/caddyhttp/reverseproxy/streaming.go","category_groups":["PII","Personal Data"],"source":{"start":418,"end":418,"column":{"start":22,"end":43}},"sink":{"start":418,"end":418,"column":{"start":22,"end":43},"content":""},"parent_line_number":418,"fingerprint":"161d3c480de3c448dd23c15045e7402d_0","old_fingerprint":"161d3c480de3c448dd23c15045e7402d_0","code_extract":"\tif n := int(uintptr(unsafe.Pointer(\u0026b[0]))) % wordSize; n != 0 {"},{"cwe_ids":["242"],"id":"go_gosec_unsafe_unsafe","title":"Usage of vulnerable 'unsafe' package","description":"## Description\n\nThe `unsafe` package in Go allows for low-level memory management, including direct memory access and pointer manipulation. While `unsafe` is a powerful library, using it bypasses Go's type safety checks and opens the door to security vulnerabilities and unpredictable behavior in your application.\n\n## Remediations\n\n- **Do not** use the `unsafe` package unless it is absolutely necessary. If you must use it, ensure you fully understand the implications and thoroughly test your code.\n- **Do** ensure buffer boundaries are respected to avoid buffer overflows. This precaution helps prevent unauthorized code execution.\n  ```go\n  buffer := make([]byte, 10)\n  ```\n- **Do not** access memory after it has been freed to avoid use-after-free vulnerabilities, which can lead to unintended code execution or unpredictable system behavior.\n  ```go\n  unsafePointer := unsafe.Pointer(\u0026data)\n  C.free(unsafePointer)\n  // now unsafe to access\n  ```\n- **Do** regularly review and audit your code to prevent memory or information leaks that could compromise security or lead to system failures due to exhausted memory.\n\n## References\n\n- [Buffer Overflows - OWASP](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [Using Freed Memory - OWASP](https://owasp.org/www-community/vulnerabilities/Using_freed_memory)\n- [Memory Leaks - OWASP](https://owasp.org/www-community/vulnerabilities/Memory_leak)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_unsafe_unsafe","line_number":432,"full_filename":"modules/caddyhttp/reverseproxy/streaming.go","filename":"modules/caddyhttp/reverseproxy/streaming.go","category_groups":["PII","Personal Data"],"source":{"start":432,"end":432,"column":{"start":20,"end":38}},"sink":{"start":432,"end":432,"column":{"start":20,"end":38},"content":""},"parent_line_number":432,"fingerprint":"161d3c480de3c448dd23c15045e7402d_1","old_fingerprint":"161d3c480de3c448dd23c15045e7402d_1","code_extract":"\tkw := *(*uintptr)(unsafe.Pointer(\u0026k))"},{"cwe_ids":["242"],"id":"go_gosec_unsafe_unsafe","title":"Usage of vulnerable 'unsafe' package","description":"## Description\n\nThe `unsafe` package in Go allows for low-level memory management, including direct memory access and pointer manipulation. While `unsafe` is a powerful library, using it bypasses Go's type safety checks and opens the door to security vulnerabilities and unpredictable behavior in your application.\n\n## Remediations\n\n- **Do not** use the `unsafe` package unless it is absolutely necessary. If you must use it, ensure you fully understand the implications and thoroughly test your code.\n- **Do** ensure buffer boundaries are respected to avoid buffer overflows. This precaution helps prevent unauthorized code execution.\n  ```go\n  buffer := make([]byte, 10)\n  ```\n- **Do not** access memory after it has been freed to avoid use-after-free vulnerabilities, which can lead to unintended code execution or unpredictable system behavior.\n  ```go\n  unsafePointer := unsafe.Pointer(\u0026data)\n  C.free(unsafePointer)\n  // now unsafe to access\n  ```\n- **Do** regularly review and audit your code to prevent memory or information leaks that could compromise security or lead to system failures due to exhausted memory.\n\n## References\n\n- [Buffer Overflows - OWASP](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [Using Freed Memory - OWASP](https://owasp.org/www-community/vulnerabilities/Using_freed_memory)\n- [Memory Leaks - OWASP](https://owasp.org/www-community/vulnerabilities/Memory_leak)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_unsafe_unsafe","line_number":437,"full_filename":"modules/caddyhttp/reverseproxy/streaming.go","filename":"modules/caddyhttp/reverseproxy/streaming.go","category_groups":["PII","Personal Data"],"source":{"start":437,"end":437,"column":{"start":15,"end":74}},"sink":{"start":437,"end":437,"column":{"start":15,"end":74},"content":""},"parent_line_number":437,"fingerprint":"161d3c480de3c448dd23c15045e7402d_2","old_fingerprint":"161d3c480de3c448dd23c15045e7402d_2","code_extract":"\t\t*(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(\u0026b[0])) + uintptr(i))) ^= kw"},{"cwe_ids":["242"],"id":"go_gosec_unsafe_unsafe","title":"Usage of vulnerable 'unsafe' package","description":"## Description\n\nThe `unsafe` package in Go allows for low-level memory management, including direct memory access and pointer manipulation. While `unsafe` is a powerful library, using it bypasses Go's type safety checks and opens the door to security vulnerabilities and unpredictable behavior in your application.\n\n## Remediations\n\n- **Do not** use the `unsafe` package unless it is absolutely necessary. If you must use it, ensure you fully understand the implications and thoroughly test your code.\n- **Do** ensure buffer boundaries are respected to avoid buffer overflows. This precaution helps prevent unauthorized code execution.\n  ```go\n  buffer := make([]byte, 10)\n  ```\n- **Do not** access memory after it has been freed to avoid use-after-free vulnerabilities, which can lead to unintended code execution or unpredictable system behavior.\n  ```go\n  unsafePointer := unsafe.Pointer(\u0026data)\n  C.free(unsafePointer)\n  // now unsafe to access\n  ```\n- **Do** regularly review and audit your code to prevent memory or information leaks that could compromise security or lead to system failures due to exhausted memory.\n\n## References\n\n- [Buffer Overflows - OWASP](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [Using Freed Memory - OWASP](https://owasp.org/www-community/vulnerabilities/Using_freed_memory)\n- [Memory Leaks - OWASP](https://owasp.org/www-community/vulnerabilities/Memory_leak)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_unsafe_unsafe","line_number":557,"full_filename":"modules/caddyhttp/reverseproxy/streaming.go","filename":"modules/caddyhttp/reverseproxy/streaming.go","category_groups":["PII","Personal Data"],"source":{"start":557,"end":557,"column":{"start":26,"end":51}},"sink":{"start":557,"end":557,"column":{"start":26,"end":51},"content":""},"parent_line_number":557,"fingerprint":"161d3c480de3c448dd23c15045e7402d_3","old_fingerprint":"161d3c480de3c448dd23c15045e7402d_3","code_extract":"\twordSize          = int(unsafe.Sizeof(uintptr(0)))"},{"cwe_ids":["327"],"id":"go_lang_missing_tls_minversion","title":"Missing TLS MinVersion","description":"## Description\n\nOlder versions of TLS (Transport Layer Security) have been deprecated because of known security issues. To enhance security, it is crucial to specify the highest possible minimum version of TLS that your server will accept.\n\n## Remediations\n\n- **Do** set `MinVersion` in the `tls.Config` struct to `tls.VersionTLS13`. This ensures your server only accepts connections using the most secure, up-to-date version of TLS.\n  ```go\n  {\n    MinVersion: tls.VersionTLS13\n  }\n  ```\n- **Do** configure `MinVersion` to the highest possible supported version of TLS for legacy applications that cannot use TLS 1.3. This step is essential for maintaining security while ensuring compatibility.\n\n## References\n\n- [OWASP TLS Cipher String Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html)","documentation_url":"https://docs.bearer.com/reference/rules/go_lang_missing_tls_minversion","line_number":324,"full_filename":"caddytest/caddytest.go","filename":"caddytest/caddytest.go","category_groups":["PII","Personal Data"],"source":{"start":324,"end":324,"column":{"start":27,"end":63}},"sink":{"start":324,"end":324,"column":{"start":27,"end":63},"content":""},"parent_line_number":324,"fingerprint":"13792b919f80bc1f94d7bb8a1b985097_0","old_fingerprint":"13792b919f80bc1f94d7bb8a1b985097_0","code_extract":"\t\tTLSClientConfig:       \u0026tls.Config{InsecureSkipVerify: true}, //nolint:gosec"},{"cwe_ids":["327"],"id":"go_lang_missing_tls_minversion","title":"Missing TLS MinVersion","description":"## Description\n\nOlder versions of TLS (Transport Layer Security) have been deprecated because of known security issues. To enhance security, it is crucial to specify the highest possible minimum version of TLS that your server will accept.\n\n## Remediations\n\n- **Do** set `MinVersion` in the `tls.Config` struct to `tls.VersionTLS13`. This ensures your server only accepts connections using the most secure, up-to-date version of TLS.\n  ```go\n  {\n    MinVersion: tls.VersionTLS13\n  }\n  ```\n- **Do** configure `MinVersion` to the highest possible supported version of TLS for legacy applications that cannot use TLS 1.3. This step is essential for maintaining security while ensuring compatibility.\n\n## References\n\n- [OWASP TLS Cipher String Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html)","documentation_url":"https://docs.bearer.com/reference/rules/go_lang_missing_tls_minversion","line_number":474,"full_filename":"listeners.go","filename":"listeners.go","category_groups":["PII","Personal Data"],"source":{"start":474,"end":474,"column":{"start":21,"end":75}},"sink":{"start":474,"end":474,"column":{"start":21,"end":75},"content":""},"parent_line_number":474,"fingerprint":"46e4ed8f3dccbf2b703536a5560fd90f_0","old_fingerprint":"46e4ed8f3dccbf2b703536a5560fd90f_1","code_extract":"\t\tquicTlsConfig := \u0026tls.Config{GetConfigForClient: sqs.getConfigForClient}"},{"cwe_ids":["327"],"id":"go_lang_missing_tls_minversion","title":"Missing TLS MinVersion","description":"## Description\n\nOlder versions of TLS (Transport Layer Security) have been deprecated because of known security issues. To enhance security, it is crucial to specify the highest possible minimum version of TLS that your server will accept.\n\n## Remediations\n\n- **Do** set `MinVersion` in the `tls.Config` struct to `tls.VersionTLS13`. This ensures your server only accepts connections using the most secure, up-to-date version of TLS.\n  ```go\n  {\n    MinVersion: tls.VersionTLS13\n  }\n  ```\n- **Do** configure `MinVersion` to the highest possible supported version of TLS for legacy applications that cannot use TLS 1.3. This step is essential for maintaining security while ensuring compatibility.\n\n## References\n\n- [OWASP TLS Cipher String Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/TLS_Cipher_String_Cheat_Sheet.html)","documentation_url":"https://docs.bearer.com/reference/rules/go_lang_missing_tls_minversion","line_number":513,"full_filename":"listeners.go","filename":"listeners.go","category_groups":["PII","Personal Data"],"source":{"start":513,"end":513,"column":{"start":21,"end":75}},"sink":{"start":513,"end":513,"column":{"start":21,"end":75},"content":""},"parent_line_number":513,"fingerprint":"46e4ed8f3dccbf2b703536a5560fd90f_1","old_fingerprint":"46e4ed8f3dccbf2b703536a5560fd90f_2","code_extract":"\t\tquicTlsConfig := \u0026tls.Config{GetConfigForClient: sqs.getConfigForClient}"},{"cwe_ids":["295"],"id":"go_lang_ssl_verification","title":"Missing SSL certificate verification","description":"## Description\n\nYour application's security is compromised if it fails to verify SSL certificates. This vulnerability occurs when your application communicates over HTTPS without validating the authenticity of the SSL certificate presented by the server. It exposes sensitive data to interception by attackers.\n\n## Remediations\n\n- **Do not** disable SSL certificate validation in your HTTP client. Disabling it makes your application vulnerable to Man-in-the-Middle (MitM) attacks.\n- **Do** ensure that your HTTP client is configured to verify both the SSL certificate's validity and the hostname. This step is crucial for establishing a secure connection.","documentation_url":"https://docs.bearer.com/reference/rules/go_lang_ssl_verification","line_number":324,"full_filename":"caddytest/caddytest.go","filename":"caddytest/caddytest.go","category_groups":["PII","Personal Data"],"source":{"start":324,"end":324,"column":{"start":38,"end":62}},"sink":{"start":324,"end":324,"column":{"start":38,"end":62},"content":""},"parent_line_number":324,"fingerprint":"254e18abb7621501ed07879b9a8059c6_0","old_fingerprint":"254e18abb7621501ed07879b9a8059c6_1","code_extract":"\t\tTLSClientConfig:       \u0026tls.Config{InsecureSkipVerify: true}, //nolint:gosec"},{"cwe_ids":["295"],"id":"go_lang_ssl_verification","title":"Missing SSL certificate verification","description":"## Description\n\nYour application's security is compromised if it fails to verify SSL certificates. This vulnerability occurs when your application communicates over HTTPS without validating the authenticity of the SSL certificate presented by the server. It exposes sensitive data to interception by attackers.\n\n## Remediations\n\n- **Do not** disable SSL certificate validation in your HTTP client. Disabling it makes your application vulnerable to Man-in-the-Middle (MitM) attacks.\n- **Do** ensure that your HTTP client is configured to verify both the SSL certificate's validity and the hostname. This step is crucial for establishing a secure connection.","documentation_url":"https://docs.bearer.com/reference/rules/go_lang_ssl_verification","line_number":1073,"full_filename":"modules/caddyhttp/reverseproxy/caddyfile.go","filename":"modules/caddyhttp/reverseproxy/caddyfile.go","category_groups":["PII","Personal Data"],"source":{"start":1073,"end":1073,"column":{"start":5,"end":36}},"sink":{"start":1073,"end":1073,"column":{"start":5,"end":36},"content":""},"parent_line_number":1073,"fingerprint":"a6cba1cb808c9e5e820d02cc94d22878_0","old_fingerprint":"a6cba1cb808c9e5e820d02cc94d22878_2","code_extract":"\t\t\t\th.TLS.InsecureSkipVerify = true"},{"cwe_ids":["295"],"id":"go_lang_ssl_verification","title":"Missing SSL certificate verification","description":"## Description\n\nYour application's security is compromised if it fails to verify SSL certificates. This vulnerability occurs when your application communicates over HTTPS without validating the authenticity of the SSL certificate presented by the server. It exposes sensitive data to interception by attackers.\n\n## Remediations\n\n- **Do not** disable SSL certificate validation in your HTTP client. Disabling it makes your application vulnerable to Man-in-the-Middle (MitM) attacks.\n- **Do** ensure that your HTTP client is configured to verify both the SSL certificate's validity and the hostname. This step is crucial for establishing a secure connection.","documentation_url":"https://docs.bearer.com/reference/rules/go_lang_ssl_verification","line_number":152,"full_filename":"modules/caddyhttp/reverseproxy/command.go","filename":"modules/caddyhttp/reverseproxy/command.go","category_groups":["PII","Personal Data"],"source":{"start":152,"end":152,"column":{"start":4,"end":36}},"sink":{"start":152,"end":152,"column":{"start":4,"end":36},"content":""},"parent_line_number":152,"fingerprint":"c903f07f5d2217e300372230e4f9f709_0","old_fingerprint":"c903f07f5d2217e300372230e4f9f709_0","code_extract":"\t\t\tht.TLS.InsecureSkipVerify = true"}],"medium":[{"cwe_ids":["200"],"id":"go_gosec_leak_pprof_endpoint","title":"Usage of active debug code (pprof enabled)","description":"## Description\n\nEnabling Go's `net/http/pprof` in production environments exposes runtime profiling data via a `/debug/pprof` endpoint, creating a security vulnerability. This tool is part of Go's standard library and, while useful for debugging, it does not have authentication controls. This can lead to sensitive information leaks about the application's runtime state and environment if left accessible in production.\n\n## Remediations\n\n- **Do not** include `net/http/pprof` in your production code. Remove any imports of this package before deploying to ensure the profiling endpoint is not exposed.\n- **Do** use build tags for conditional compilation, and only allow profiling in non-production builds.\n- **Do** configure environment-specific settings to enable or disable profiling endpoints based on the deployment environment.\n- **Do** implement strong authentication mechanisms if profiling must be enabled in a controlled production scenario to secure the endpoint.\n\n## References\n\n- [Go net/http/pprof Package Documentation](https://pkg.go.dev/net/http/pprof)\n- [Go Build Constraints Documentation](https://pkg.go.dev/go/build#hdr-Build_Constraints)\n- [OWASP Secure Product Design Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Secure_Product_Design_Cheat_Sheet.html)","documentation_url":"https://docs.bearer.com/reference/rules/go_gosec_leak_pprof_endpoint","line_number":33,"full_filename":"admin.go","filename":"admin.go","category_groups":["PII","Personal Data"],"source":{"start":33,"end":33,"column":{"start":2,"end":18}},"sink":{"start":33,"end":33,"column":{"start":2,"end":18},"content":""},"parent_line_number":33,"fingerprint":"92c2f645a7c6bf67be97a9e6228354d9_0","old_fingerprint":"92c2f645a7c6bf67be97a9e6228354d9_0","code_extract":"\t\"net/http/pprof\""},{"cwe_ids":["1004"],"id":"go_lang_cookie_missing_http_only","title":"Missing HTTP Only option in cookie configuration","description":"## Description\n\nMissing the HTTP Only option in cookie configuration exposes cookies to client-side script access. This vulnerability occurs when cookies are set without the `HttpOnly` attribute, allowing them to be accessible via JavaScript. This can lead to sensitive information being compromised, especially if the site is susceptible to Cross-Site Scripting (XSS) attacks.\n\n## Remediations\n\n- **Do** set the `HttpOnly` attribute for cookies to `true`. This action prevents client-side scripts from accessing the cookie, significantly reducing the risk of XSS attacks.\n  ```go\n  http.SetCookie(w, \u0026http.Cookie{\n      Name:     \"session_token\",\n      Value:    sessionToken,\n      HttpOnly: true,\n      ...\n  })\n  ```\n- **Do** also consider setting `Secure`, `SameSite`, and `Domain` attributes for cookies. These additional configurations help in further securing cookies against various web vulnerabilities, tailoring the protection to your application's specific needs.\n\n## References\n\n- [OWASP Secure Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n- [MDN Web Docs: HttpOnly Cookie Attribute](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)","documentation_url":"https://docs.bearer.com/reference/rules/go_lang_cookie_missing_http_only","line_number":183,"full_filename":"modules/caddyhttp/fileserver/browse.go","filename":"modules/caddyhttp/fileserver/browse.go","category_groups":["PII","Personal Data"],"source":{"start":183,"end":183,"column":{"start":22,"end":87}},"sink":{"start":183,"end":183,"column":{"start":22,"end":87},"content":""},"parent_line_number":183,"fingerprint":"b58e45333e8a7dbd565e3eb9f9c7745d_0","old_fingerprint":"b58e45333e8a7dbd565e3eb9f9c7745d_0","code_extract":"\t\thttp.SetCookie(w, \u0026http.Cookie{Name: \"sort\", Value: sortParam, Secure: r.TLS != nil})"},{"cwe_ids":["1004"],"id":"go_lang_cookie_missing_http_only","title":"Missing HTTP Only option in cookie configuration","description":"## Description\n\nMissing the HTTP Only option in cookie configuration exposes cookies to client-side script access. This vulnerability occurs when cookies are set without the `HttpOnly` attribute, allowing them to be accessible via JavaScript. This can lead to sensitive information being compromised, especially if the site is susceptible to Cross-Site Scripting (XSS) attacks.\n\n## Remediations\n\n- **Do** set the `HttpOnly` attribute for cookies to `true`. This action prevents client-side scripts from accessing the cookie, significantly reducing the risk of XSS attacks.\n  ```go\n  http.SetCookie(w, \u0026http.Cookie{\n      Name:     \"session_token\",\n      Value:    sessionToken,\n      HttpOnly: true,\n      ...\n  })\n  ```\n- **Do** also consider setting `Secure`, `SameSite`, and `Domain` attributes for cookies. These additional configurations help in further securing cookies against various web vulnerabilities, tailoring the protection to your application's specific needs.\n\n## References\n\n- [OWASP Secure Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n- [MDN Web Docs: HttpOnly Cookie Attribute](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)","documentation_url":"https://docs.bearer.com/reference/rules/go_lang_cookie_missing_http_only","line_number":194,"full_filename":"modules/caddyhttp/fileserver/browse.go","filename":"modules/caddyhttp/fileserver/browse.go","category_groups":["PII","Personal Data"],"source":{"start":194,"end":194,"column":{"start":22,"end":89}},"sink":{"start":194,"end":194,"column":{"start":22,"end":89},"content":""},"parent_line_number":194,"fingerprint":"b58e45333e8a7dbd565e3eb9f9c7745d_1","old_fingerprint":"b58e45333e8a7dbd565e3eb9f9c7745d_1","code_extract":"\t\thttp.SetCookie(w, \u0026http.Cookie{Name: \"order\", Value: orderParam, Secure: r.TLS != nil})"},{"cwe_ids":["1004"],"id":"go_lang_cookie_missing_http_only","title":"Missing HTTP Only option in cookie configuration","description":"## Description\n\nMissing the HTTP Only option in cookie configuration exposes cookies to client-side script access. This vulnerability occurs when cookies are set without the `HttpOnly` attribute, allowing them to be accessible via JavaScript. This can lead to sensitive information being compromised, especially if the site is susceptible to Cross-Site Scripting (XSS) attacks.\n\n## Remediations\n\n- **Do** set the `HttpOnly` attribute for cookies to `true`. This action prevents client-side scripts from accessing the cookie, significantly reducing the risk of XSS attacks.\n  ```go\n  http.SetCookie(w, \u0026http.Cookie{\n      Name:     \"session_token\",\n      Value:    sessionToken,\n      HttpOnly: true,\n      ...\n  })\n  ```\n- **Do** also consider setting `Secure`, `SameSite`, and `Domain` attributes for cookies. These additional configurations help in further securing cookies against various web vulnerabilities, tailoring the protection to your application's specific needs.\n\n## References\n\n- [OWASP Secure Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n- [MDN Web Docs: HttpOnly Cookie Attribute](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)","documentation_url":"https://docs.bearer.com/reference/rules/go_lang_cookie_missing_http_only","line_number":663,"full_filename":"modules/caddyhttp/reverseproxy/selectionpolicies.go","filename":"modules/caddyhttp/reverseproxy/selectionpolicies.go","category_groups":["PII","Personal Data"],"source":{"start":663,"end":668,"column":{"start":22,"end":4}},"sink":{"start":663,"end":668,"column":{"start":22,"end":4},"content":""},"parent_line_number":663,"fingerprint":"1b636828e6f0d0430458fd7415c0e05d_0","old_fingerprint":"1b636828e6f0d0430458fd7415c0e05d_2","code_extract":"\t\thttp.SetCookie(w, \u0026http.Cookie{\n\t\t\tName:   s.Name,\n\t\t\tValue:  sha,\n\t\t\tPath:   \"/\",\n\t\t\tSecure: false,\n\t\t})"},{"cwe_ids":["614"],"id":"go_lang_insecure_cookie","title":"Missing Secure option in cookie configuration","description":"## Description\n\nMissing the Secure option in cookie configuration can compromise cookie security. The Secure attribute, when set to true, ensures cookies are sent to the server only over HTTPS, protecting them from interception by unauthorized parties.\n\n## Remediations\n\n- **Do** set the `Secure` attribute for cookies to `true`. This ensures cookies are transmitted securely over HTTPS, preventing unauthorized access.\n  ```go\n  http.SetCookie(w, \u0026http.Cookie{\n      Name:     \"session_token\",\n      Value:    sessionToken,\n      Secure:   true,\n      // Additional flags like HttpOnly, SameSite, etc., should be set as needed.\n  })\n  ```\n- **Do** also set `HttpOnly`, `SameSite`, and `Domain` attributes for cookies as needed by your application. These attributes provide additional layers of security for your cookies.\n\n## References\n\n- [OWASP Secure Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n- [MDN Web Docs: HttpOnly Cookie Attribute](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)","documentation_url":"https://docs.bearer.com/reference/rules/go_lang_insecure_cookie","line_number":183,"full_filename":"modules/caddyhttp/fileserver/browse.go","filename":"modules/caddyhttp/fileserver/browse.go","category_groups":["PII","Personal Data"],"source":{"start":183,"end":183,"column":{"start":22,"end":87}},"sink":{"start":183,"end":183,"column":{"start":22,"end":87},"content":""},"parent_line_number":183,"fingerprint":"48c39eb57e1dc955031571867d3be44c_0","old_fingerprint":"48c39eb57e1dc955031571867d3be44c_0","code_extract":"\t\thttp.SetCookie(w, \u0026http.Cookie{Name: \"sort\", Value: sortParam, Secure: r.TLS != nil})"},{"cwe_ids":["614"],"id":"go_lang_insecure_cookie","title":"Missing Secure option in cookie configuration","description":"## Description\n\nMissing the Secure option in cookie configuration can compromise cookie security. The Secure attribute, when set to true, ensures cookies are sent to the server only over HTTPS, protecting them from interception by unauthorized parties.\n\n## Remediations\n\n- **Do** set the `Secure` attribute for cookies to `true`. This ensures cookies are transmitted securely over HTTPS, preventing unauthorized access.\n  ```go\n  http.SetCookie(w, \u0026http.Cookie{\n      Name:     \"session_token\",\n      Value:    sessionToken,\n      Secure:   true,\n      // Additional flags like HttpOnly, SameSite, etc., should be set as needed.\n  })\n  ```\n- **Do** also set `HttpOnly`, `SameSite`, and `Domain` attributes for cookies as needed by your application. These attributes provide additional layers of security for your cookies.\n\n## References\n\n- [OWASP Secure Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n- [MDN Web Docs: HttpOnly Cookie Attribute](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)","documentation_url":"https://docs.bearer.com/reference/rules/go_lang_insecure_cookie","line_number":194,"full_filename":"modules/caddyhttp/fileserver/browse.go","filename":"modules/caddyhttp/fileserver/browse.go","category_groups":["PII","Personal Data"],"source":{"start":194,"end":194,"column":{"start":22,"end":89}},"sink":{"start":194,"end":194,"column":{"start":22,"end":89},"content":""},"parent_line_number":194,"fingerprint":"48c39eb57e1dc955031571867d3be44c_1","old_fingerprint":"48c39eb57e1dc955031571867d3be44c_1","code_extract":"\t\thttp.SetCookie(w, \u0026http.Cookie{Name: \"order\", Value: orderParam, Secure: r.TLS != nil})"},{"cwe_ids":["614"],"id":"go_lang_insecure_cookie","title":"Missing Secure option in cookie configuration","description":"## Description\n\nMissing the Secure option in cookie configuration can compromise cookie security. The Secure attribute, when set to true, ensures cookies are sent to the server only over HTTPS, protecting them from interception by unauthorized parties.\n\n## Remediations\n\n- **Do** set the `Secure` attribute for cookies to `true`. This ensures cookies are transmitted securely over HTTPS, preventing unauthorized access.\n  ```go\n  http.SetCookie(w, \u0026http.Cookie{\n      Name:     \"session_token\",\n      Value:    sessionToken,\n      Secure:   true,\n      // Additional flags like HttpOnly, SameSite, etc., should be set as needed.\n  })\n  ```\n- **Do** also set `HttpOnly`, `SameSite`, and `Domain` attributes for cookies as needed by your application. These attributes provide additional layers of security for your cookies.\n\n## References\n\n- [OWASP Secure Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)\n- [MDN Web Docs: HttpOnly Cookie Attribute](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies#restrict_access_to_cookies)","documentation_url":"https://docs.bearer.com/reference/rules/go_lang_insecure_cookie","line_number":663,"full_filename":"modules/caddyhttp/reverseproxy/selectionpolicies.go","filename":"modules/caddyhttp/reverseproxy/selectionpolicies.go","category_groups":["PII","Personal Data"],"source":{"start":663,"end":668,"column":{"start":22,"end":4}},"sink":{"start":663,"end":668,"column":{"start":22,"end":4},"content":""},"parent_line_number":663,"fingerprint":"8bc8739aad74ea5e3123b2b4fbad4cd8_0","old_fingerprint":"8bc8739aad74ea5e3123b2b4fbad4cd8_2","code_extract":"\t\thttp.SetCookie(w, \u0026http.Cookie{\n\t\t\tName:   s.Name,\n\t\t\tValue:  sha,\n\t\t\tPath:   \"/\",\n\t\t\tSecure: false,\n\t\t})"}]}
